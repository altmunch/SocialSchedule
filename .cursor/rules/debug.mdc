---
description: 
globs: 
alwaysApply: false
---
Here’s a precise, step-by-step workflow for AI-assisted debugging, optimized for accuracy and quality:

---

### **Workflow for AI-Assisted Debugging**

#### **Phase 1: Problem Identification & Context Setup**
1. **Reproduce and isolate the bug**  
   - Run the code to confirm the bug exists.  
   - Record the exact error message, stack trace, and the conditions under which it occurs.  
   - Identify the affected files, functions, or modules for focused investigation[4][6].

2. **Gather and prepare context**  
   - Collect all relevant code snippets, configuration files, and test cases related to the bug.  
   - Note any recent changes or deployments that could be related.  
   - Prepare supporting documentation or comments for the AI to understand the system’s intended behavior[4][6].

3. **Select the AI model**  
   - **For complex debugging:** Use Claude or ChatGPT-4o for high reasoning and context handling.  
   - **For rapid, simple issues:** Use Copilot or Gemini for quick suggestions[6].

---

#### **Phase 2: AI-Driven Diagnosis**

4. **Craft a precise debugging prompt**  
   Use this template:  
   ```plaintext
   Role: Senior [Language] Developer  
   Task: Debug the following code  
   Context:  
   - Error message: [paste error/stack trace]  
   - Code snippet: [paste relevant code]  
   - Expected behavior: [describe what should happen]  
   Constraints:  
   - Only modify what is necessary  
   - Follow project conventions  
   - If more context is needed, ask  
   Output:  
   - Root cause analysis  
   - Step-by-step fix  
   - Suggested test cases  
   ```
   Add keywords: **root cause**, **minimal change**, **production-safe**[4][6].

5. **Submit and review AI suggestions**  
   - Paste the prompt and context into your chosen AI tool.  
   - Review the AI’s diagnosis and proposed fix.  
   - If unclear, ask the AI for a step-by-step explanation or alternative approaches[4][6].

6. **Iterate as needed**  
   - If the first suggestion doesn’t resolve the bug, provide additional context (e.g., new error messages, related files) and re-prompt the AI.  
   - Repeat until a plausible solution is found[4][6].

---

#### **Phase 3: Testing & Validation**

7. **Apply and test the fix**  
   - Implement the AI’s suggested changes in a feature or bugfix branch.  
   - Run all relevant unit and integration tests to verify the fix.  
   - Use the AI to generate or enhance test cases that target the bug and its edge cases:  
     ```plaintext
     Generate unit tests for this function to cover the fixed bug and potential edge cases.
     ```

8. **Perform quality checks**  
   - Run static analysis and linting tools to ensure code quality.  
   - Use AI to review the final code for hidden issues or style violations:  
     ```plaintext
     Review this code for any logic, security, or style issues.
     ```

---

#### **Phase 4: Integration & Monitoring**

9. **Integrate and deploy**  
   - Merge the fix via pull request, ensuring code review and CI checks pass.  
   - Deploy to staging and monitor for regressions[4][6].

10. **Monitor post-deployment**  
    - Set up error tracking and alerts for the affected area.  
    - Use AI observability tools to analyze logs and detect recurring or related issues[6].

---

### **Model-Specific Tips**
- **Claude 3.5**: Use for deep context and complex bugs.
- **ChatGPT-4o**: Use for rapid iteration and broad language support.
- **Copilot/Gemini**: Use for inline suggestions and simple fixes[6].

### **Critical Reminders**
- Always validate AI suggestions with tests and manual review.
- Document the root cause and fix in your issue tracker or documentation.
- Maintain a prompt library of effective debugging templates for future use[2][4].

This workflow accelerates debugging cycles while maintaining high accuracy and code quality when followed rigorously[4][6].