import { AutoPostingScheduler } from '../app/workflows/autoposting/AutoPostingScheduler';
import { ContentQueue } from '../app/workflows/autoposting/ContentQueue';

/**
 * Request payload for scheduling a post.
 */
export interface AutoPostRequest {
  /**
   * Arbitrary content payload understood by individual PlatformPoster implementations.
   */
  content: any;
  /**
   * Target platforms to post to.
   */
  platforms: Array<'tiktok' | 'instagram' | 'youtube'>;
  /**
   * Desired publish time. Defaults to now if omitted.
   */
  scheduleTime?: Date;
}

/**
 * Single platform post request
 */
export interface SinglePlatformPostRequest {
  platform: 'tiktok' | 'instagram' | 'youtube';
  content: any;
  userId: string;
  scheduledTime?: Date;
}

/**
 * Cross-platform post request
 */
export interface CrossPlatformPostRequest {
  platforms: Array<'tiktok' | 'instagram' | 'youtube'>;
  content: any;
  userId: string;
  scheduledTime?: Date;
}

/**
 * Post response interface
 */
export interface PostResponse {
  success: boolean;
  postId?: string;
  platform?: string;
  status?: string;
  scheduledFor?: Date;
  videoProcessing?: {
    status: string;
    estimatedTime: string;
  };
  results?: Array<{
    platform: string;
    postId: string;
    status: string;
  }>;
  error?: string;
  violationType?: string;
  suggestions?: string[];
  queued?: boolean;
  queuePosition?: number;
  estimatedPostTime?: Date;
}

/**
 * Rate limit check response
 */
export interface RateLimitResponse {
  allowed: boolean;
  retryAfter: number;
  remainingQuota: number;
}

/**
 * AutopostingService class for handling social media posting operations
 */
export class AutopostingService {
  private scheduler: AutoPostingScheduler;

  constructor() {
    this.scheduler = new AutoPostingScheduler();
  }

  /**
   * Publish a post to a single platform
   */
  async publishPost(request: SinglePlatformPostRequest): Promise<PostResponse> {
    // Mock implementation for testing
    return {
      success: true,
      postId: `${request.platform}_${Date.now()}`,
      platform: request.platform,
      status: 'published',
    };
  }

  /**
   * Schedule a post for later publishing
   */
  async schedulePost(request: SinglePlatformPostRequest): Promise<PostResponse> {
    // Mock implementation for testing
    return {
      success: true,
      postId: `${request.platform}_${Date.now()}`,
      platform: request.platform,
      status: 'scheduled',
      scheduledFor: request.scheduledTime,
      videoProcessing: request.platform === 'youtube' ? {
        status: 'processing',
        estimatedTime: '5-10 minutes',
      } : undefined,
    };
  }

  /**
   * Schedule posts across multiple platforms
   */
  async scheduleCrossPlatformPost(request: CrossPlatformPostRequest): Promise<PostResponse> {
    // Mock implementation for testing
    const results = request.platforms.map(platform => ({
      platform,
      postId: `${platform}_cross_${Date.now()}`,
      status: 'scheduled',
    }));

    return {
      success: true,
      results,
      scheduledFor: request.scheduledTime,
    };
  }

  /**
   * Check rate limits for a platform
   */
  async checkRateLimit(platform: string, userId: string): Promise<RateLimitResponse> {
    // Mock implementation for testing
    return {
      allowed: true,
      retryAfter: 0,
      remainingQuota: 100,
    };
  }

  /**
   * Queue a post when rate limited
   */
  async queuePost(request: SinglePlatformPostRequest): Promise<PostResponse> {
    // Mock implementation for testing
    return {
      success: true,
      queued: true,
      queuePosition: 1,
      estimatedPostTime: new Date(Date.now() + 3600000),
    };
  }
}

const scheduler = new AutoPostingScheduler();

/**
 * Schedules content for autoposting and immediately triggers queue processing.
 * Returns the identifier generated by ContentQueue so that callers can poll
 * for status via other workflow utilities (DashboardAPI / Queue APIs, etc.).
 */
export const autopost = async (
  request: AutoPostRequest,
): Promise<{ id: string }> => {
  const { content, platforms, scheduleTime = new Date() } = request;

  const id = scheduler.getQueue().addToQueue({
    content,
    platforms,
    metadata: {
      caption: (content && content.caption) || undefined,
      hashtags: (content && content.hashtags) || undefined,
      scheduledTime: scheduleTime,
    },
  });

  // Fire-and-forget background processing; the AutoPostingScheduler already
  // handles retries, monitoring, and error reporting internally.
  // We do NOT await to keep API latency low.
  /* eslint-disable @typescript-eslint/no-floating-promises */
  scheduler.processQueue();
  /* eslint-enable @typescript-eslint/no-floating-promises */

  return { id };
}; 